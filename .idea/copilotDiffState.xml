<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/typejam/LoadingScreenController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/typejam/LoadingScreenController.java" />
              <option name="updatedContent" value="package com.example.typejam;&#10;&#10;import javafx.animation.PauseTransition;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.scene.Parent;&#10;import javafx.scene.Scene;&#10;import javafx.scene.control.ProgressIndicator;&#10;import javafx.stage.Stage;&#10;import javafx.util.Duration;&#10;&#10;import java.io.IOException;&#10;&#10;public class LoadingScreenController {&#10;&#10;    @FXML&#10;    private ProgressIndicator loadingSpinner;&#10;&#10;    @FXML&#10;    public void initialize() {&#10;        // Create a 2-second delay before transitioning to result scene&#10;        PauseTransition pause = new PauseTransition(Duration.seconds(2));&#10;        pause.setOnFinished(event -&gt; {&#10;            try {&#10;                loadResultScene();&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;                System.err.println(&quot;Error loading result-scene.fxml: &quot; + e.getMessage());&#10;            }&#10;        });&#10;        pause.play();&#10;    }&#10;&#10;    private void loadResultScene() throws IOException {&#10;        FXMLLoader loader = new FXMLLoader(getClass().getResource(&quot;result-scene.fxml&quot;));&#10;        Parent root = loader.load();&#10;        Stage stage = (Stage) loadingSpinner.getScene().getWindow();&#10;        Scene scene = new Scene(root, 760, 495);&#10;        stage.setScene(scene);&#10;        stage.show();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/typejam/ResultSceneController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/typejam/ResultSceneController.java" />
              <option name="updatedContent" value="package com.example.typejam;&#10;&#10;import javafx.event.ActionEvent;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.scene.Node;&#10;import javafx.scene.Parent;&#10;import javafx.scene.Scene;&#10;import javafx.scene.control.Button;&#10;import javafx.stage.Stage;&#10;&#10;import java.io.IOException;&#10;&#10;public class ResultSceneController {&#10;&#10;    @FXML&#10;    private Button backButton;&#10;&#10;    @FXML&#10;    public void onBack(ActionEvent event) {&#10;        System.out.println(&quot;Back button clicked from result scene!&quot;);&#10;        try {&#10;            switchTo(event, &quot;main-menu.fxml&quot;);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;            System.err.println(&quot;Error loading main-menu.fxml: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void switchTo(ActionEvent event, String fxmlName) throws IOException {&#10;        FXMLLoader loader = new FXMLLoader(getClass().getResource(fxmlName));&#10;        Parent root = loader.load();&#10;        Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();&#10;        Scene scene = new Scene(root, 760, 495);&#10;        stage.setScene(scene);&#10;        stage.show();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/typejam/TypingGameController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/typejam/TypingGameController.java" />
              <option name="originalContent" value="package com.example.typejam;&#10;&#10;import javafx.animation.AnimationTimer;&#10;import javafx.event.ActionEvent;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.scene.Node;&#10;import javafx.scene.Parent;&#10;import javafx.scene.Scene;&#10;import javafx.scene.control.TextField;&#10;import javafx.scene.image.ImageView;&#10;import javafx.scene.paint.Color;&#10;import javafx.scene.text.Font;&#10;import javafx.scene.text.Text;&#10;import javafx.scene.text.TextFlow;&#10;import javafx.stage.Stage;&#10;&#10;import java.io.IOException;&#10;&#10;public class TypingGameController {&#10;&#10;    @FXML&#10;    private TextField typingField;&#10;&#10;    @FXML&#10;    private Text playerNameText;&#10;&#10;    @FXML&#10;    private Text difficultyText;&#10;&#10;    @FXML&#10;    private Text timeText;&#10;&#10;    @FXML&#10;    private TextFlow dataTextFlow;&#10;&#10;    @FXML&#10;    private javafx.scene.control.Button backButton;&#10;&#10;    @FXML&#10;    private ImageView infinityImage;&#10;&#10;    private String targetText;&#10;    private long startTime;&#10;    private AnimationTimer timer;&#10;    private boolean gameStarted = false;&#10;    private boolean gameFinished = false;&#10;    private boolean endlessMode = false;&#10;    private boolean timeChallengeMode = false;&#10;    private int timeLimitSeconds = 0;&#10;    private long countdownStartTime = 0;&#10;&#10;    // Sample texts based on difficulty&#10;    private static final String[] EASY_TEXTS = {&#10;        &quot;The quick brown fox jumps over the lazy dog.&quot;,&#10;        &quot;A journey of a thousand miles begins with a single step.&quot;,&#10;        &quot;To be or not to be, that is the question.&quot;&#10;    };&#10;&#10;    private static final String[] MEDIUM_TEXTS = {&#10;        &quot;In the midst of chaos, there is also opportunity. The wise warrior avoids the battle.&quot;,&#10;        &quot;Success is not final, failure is not fatal: it is the courage to continue that counts.&quot;,&#10;        &quot;The only impossible journey is the one you never begin. Believe in yourself always.&quot;&#10;    };&#10;&#10;    private static final String[] HARD_TEXTS = {&#10;        &quot;Programming is the art of telling another human what one wants the computer to do. It requires precision, logic, and creativity in equal measure.&quot;,&#10;        &quot;The difference between theory and practice is that in theory there is no difference, but in practice there is. This paradox applies to many areas of life.&quot;,&#10;        &quot;Innovation distinguishes between a leader and a follower. Those who dare to think differently often change the world in profound ways.&quot;&#10;    };&#10;&#10;    @FXML&#10;    public void initialize() {&#10;        // Get data from GameData singleton&#10;        GameData gameData = GameData.getInstance();&#10;        String playerName = gameData.getPlayerName() != null ? gameData.getPlayerName() : &quot;Player&quot;;&#10;        String difficulty = gameData.getDifficulty() != null ? gameData.getDifficulty() : &quot;Easy&quot;;&#10;        String mode = gameData.getMode();&#10;        String timeLimit = gameData.getTime();&#10;&#10;        // Determine game mode&#10;        endlessMode = mode != null &amp;&amp; mode.equalsIgnoreCase(&quot;Endless Mode&quot;);&#10;        timeChallengeMode = mode != null &amp;&amp; mode.equalsIgnoreCase(&quot;Time Challenge&quot;);&#10;&#10;        // Parse time limit for Time Challenge mode&#10;        if (timeChallengeMode &amp;&amp; timeLimit != null) {&#10;            timeLimitSeconds = parseTimeLimit(timeLimit);&#10;        }&#10;&#10;        // Configure timer/infinity visuals based on mode&#10;        if (endlessMode) {&#10;            // Show infinity image, hide time text&#10;            if (infinityImage != null) infinityImage.setVisible(true);&#10;            if (timeText != null) timeText.setVisible(false);&#10;        } else {&#10;            // Time challenge or other mode: hide infinity image, show timer&#10;            if (infinityImage != null) infinityImage.setVisible(false);&#10;            if (timeText != null) {&#10;                timeText.setVisible(true);&#10;                // Set initial countdown time for Time Challenge mode&#10;                if (timeChallengeMode &amp;&amp; timeLimitSeconds &gt; 0) {&#10;                    int minutes = timeLimitSeconds / 60;&#10;                    int seconds = timeLimitSeconds % 60;&#10;                    timeText.setText(String.format(&quot;%d:%02d&quot;, minutes, seconds));&#10;                }&#10;            }&#10;        }&#10;&#10;        // Truncate player name to 30 characters maximum with ellipsis&#10;        if (playerName.length() &gt; 30) {&#10;            playerName = playerName.substring(0, 30) + &quot;...&quot;;&#10;        }&#10;&#10;        // Set the text values&#10;        playerNameText.setText(playerName);&#10;        difficultyText.setText(difficulty + &quot; Level&quot;);&#10;&#10;        // Select text based on difficulty&#10;        targetText = selectTextByDifficulty(difficulty);&#10;&#10;        // Display the target text&#10;        updateTextDisplay(&quot;&quot;);&#10;&#10;        // Add listener to typing field&#10;        typingField.textProperty().addListener((observable, oldValue, newValue) -&gt; {&#10;            if (!gameStarted &amp;&amp; !newValue.isEmpty()) {&#10;                startGame();&#10;            }&#10;            if (!gameFinished) {&#10;                updateTextDisplay(newValue);&#10;                checkCompletion(newValue);&#10;            }&#10;        });&#10;&#10;        // Focus on typing field&#10;        typingField.requestFocus();&#10;    }&#10;&#10;    private String selectTextByDifficulty(String difficulty) {&#10;        String[] texts;&#10;        switch (difficulty.toLowerCase()) {&#10;            case &quot;easy&quot;:&#10;                texts = EASY_TEXTS;&#10;                break;&#10;            case &quot;medium&quot;:&#10;                texts = MEDIUM_TEXTS;&#10;                break;&#10;            case &quot;hard&quot;:&#10;                texts = HARD_TEXTS;&#10;                break;&#10;            default:&#10;                texts = EASY_TEXTS;&#10;        }&#10;        // Select a random text from the array&#10;        return texts[(int) (Math.random() * texts.length)];&#10;    }&#10;&#10;    private int parseTimeLimit(String timeLimit) {&#10;        // Parse time limits like &quot;1 Minute&quot;, &quot;3 Minutes&quot;, &quot;5 Minutes&quot;&#10;        if (timeLimit == null) return 0;&#10;&#10;        String[] parts = timeLimit.split(&quot; &quot;);&#10;        if (parts.length &gt; 0) {&#10;            try {&#10;                int minutes = Integer.parseInt(parts[0]);&#10;                return minutes * 60; // Convert to seconds&#10;            } catch (NumberFormatException e) {&#10;                System.err.println(&quot;Could not parse time limit: &quot; + timeLimit);&#10;                return 0;&#10;            }&#10;        }&#10;        return 0;&#10;    }&#10;&#10;    private void startGame() {&#10;        gameStarted = true;&#10;        if (endlessMode) {&#10;            // Endless mode: no timer needed&#10;            return;&#10;        }&#10;&#10;        startTime = System.nanoTime();&#10;        countdownStartTime = System.nanoTime();&#10;&#10;        if (timeChallengeMode &amp;&amp; timeLimitSeconds &gt; 0) {&#10;            // Time Challenge mode: countdown timer&#10;            timer = new AnimationTimer() {&#10;                @Override&#10;                public void handle(long now) {&#10;                    long elapsedMillis = (now - countdownStartTime) / 1_000_000;&#10;                    int elapsedSeconds = (int) (elapsedMillis / 1000);&#10;                    int remainingSeconds = timeLimitSeconds - elapsedSeconds;&#10;&#10;                    if (remainingSeconds &lt;= 0) {&#10;                        // Time's up!&#10;                        remainingSeconds = 0;&#10;                        if (timeText != null) {&#10;                            timeText.setText(&quot;0:00&quot;);&#10;                        }&#10;                        handleTimeUp();&#10;                        return;&#10;                    }&#10;&#10;                    int minutes = remainingSeconds / 60;&#10;                    int seconds = remainingSeconds % 60;&#10;                    if (timeText != null) {&#10;                        timeText.setText(String.format(&quot;%d:%02d&quot;, minutes, seconds));&#10;                    }&#10;                }&#10;            };&#10;        } else {&#10;            // Regular count-up timer for other modes&#10;            timer = new AnimationTimer() {&#10;                @Override&#10;                public void handle(long now) {&#10;                    long elapsedMillis = (now - startTime) / 1_000_000;&#10;                    int seconds = (int) (elapsedMillis / 1000);&#10;                    int minutes = seconds / 60;&#10;                    seconds = seconds % 60;&#10;                    if (timeText != null) {&#10;                        timeText.setText(String.format(&quot;%d:%02d&quot;, minutes, seconds));&#10;                    }&#10;                }&#10;            };&#10;        }&#10;        timer.start();&#10;    }&#10;&#10;    private void handleTimeUp() {&#10;        if (!gameFinished) {&#10;            gameFinished = true;&#10;            if (timer != null) {&#10;                timer.stop();&#10;            }&#10;            typingField.setDisable(true);&#10;            System.out.println(&quot;Time's up! Game over.&quot;);&#10;            // You can add a dialog or message here to show time's up&#10;        }&#10;    }&#10;&#10;    private void updateTextDisplay(String typedText) {&#10;        dataTextFlow.getChildren().clear();&#10;&#10;        for (int i = 0; i &lt; targetText.length(); i++) {&#10;            Text charText = new Text(String.valueOf(targetText.charAt(i)));&#10;            charText.setFont(Font.font(&quot;Arial&quot;, 28));&#10;&#10;            if (i &lt; typedText.length()) {&#10;                // Character has been typed&#10;                if (typedText.charAt(i) == targetText.charAt(i)) {&#10;                    // Correct character - green&#10;                    charText.setFill(Color.web(&quot;#28a745&quot;));&#10;                } else {&#10;                    // Incorrect character - red&#10;                    charText.setFill(Color.web(&quot;#dc3545&quot;));&#10;                }&#10;            } else {&#10;                // Character not yet typed - black&#10;                charText.setFill(Color.BLACK);&#10;            }&#10;&#10;            dataTextFlow.getChildren().add(charText);&#10;        }&#10;    }&#10;&#10;    private void checkCompletion(String typedText) {&#10;        if (typedText.equals(targetText)) {&#10;            gameFinished = true;&#10;            if (timer != null) {&#10;                timer.stop();&#10;            }&#10;            typingField.setDisable(true);&#10;&#10;            if (!endlessMode) {&#10;                // Calculate final time only for timed modes&#10;                long elapsedMillis = (System.nanoTime() - startTime) / 1_000_000;&#10;                int seconds = (int) (elapsedMillis / 1000);&#10;                int minutes = seconds / 60;&#10;                seconds = seconds % 60;&#10;                System.out.println(&quot;Game completed in &quot; + minutes + &quot;:&quot; + String.format(&quot;%02d&quot;, seconds));&#10;            } else {&#10;                System.out.println(&quot;Endless mode text completed.&quot;);&#10;            }&#10;            // You can add a completion dialog or transition here&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    public void onBack(ActionEvent event) {&#10;        System.out.println(&quot;Back button clicked!&quot;);&#10;        if (timer != null) {&#10;            timer.stop();&#10;        }&#10;        try {&#10;            switchTo(event, &quot;ready-scene.fxml&quot;);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;            System.err.println(&quot;Error loading ready-scene.fxml: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void switchTo(ActionEvent event, String fxmlName) throws IOException {&#10;        FXMLLoader loader = new FXMLLoader(getClass().getResource(fxmlName));&#10;        Parent root = loader.load();&#10;        Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();&#10;        Scene scene = new Scene(root, 760, 495);&#10;        stage.setScene(scene);&#10;        stage.show();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.typejam;&#10;&#10;import javafx.animation.AnimationTimer;&#10;import javafx.event.ActionEvent;&#10;import javafx.fxml.FXML;&#10;import javafx.fxml.FXMLLoader;&#10;import javafx.scene.Node;&#10;import javafx.scene.Parent;&#10;import javafx.scene.Scene;&#10;import javafx.scene.control.TextField;&#10;import javafx.scene.image.ImageView;&#10;import javafx.scene.paint.Color;&#10;import javafx.scene.text.Font;&#10;import javafx.scene.text.Text;&#10;import javafx.scene.text.TextFlow;&#10;import javafx.stage.Stage;&#10;&#10;import java.io.IOException;&#10;&#10;public class TypingGameController {&#10;&#10;    @FXML&#10;    private TextField typingField;&#10;&#10;    @FXML&#10;    private Text playerNameText;&#10;&#10;    @FXML&#10;    private Text difficultyText;&#10;&#10;    @FXML&#10;    private Text timeText;&#10;&#10;    @FXML&#10;    private TextFlow dataTextFlow;&#10;&#10;    @FXML&#10;    private javafx.scene.control.Button backButton;&#10;&#10;    @FXML&#10;    private ImageView infinityImage;&#10;&#10;    private String targetText;&#10;    private long startTime;&#10;    private AnimationTimer timer;&#10;    private boolean gameStarted = false;&#10;    private boolean gameFinished = false;&#10;    private boolean endlessMode = false;&#10;    private boolean timeChallengeMode = false;&#10;    private int timeLimitSeconds = 0;&#10;    private long countdownStartTime = 0;&#10;&#10;    // Sample texts based on difficulty&#10;    private static final String[] EASY_TEXTS = {&#10;        &quot;The quick brown fox jumps over the lazy dog.&quot;,&#10;        &quot;A journey of a thousand miles begins with a single step.&quot;,&#10;        &quot;To be or not to be, that is the question.&quot;&#10;    };&#10;&#10;    private static final String[] MEDIUM_TEXTS = {&#10;        &quot;In the midst of chaos, there is also opportunity. The wise warrior avoids the battle.&quot;,&#10;        &quot;Success is not final, failure is not fatal: it is the courage to continue that counts.&quot;,&#10;        &quot;The only impossible journey is the one you never begin. Believe in yourself always.&quot;&#10;    };&#10;&#10;    private static final String[] HARD_TEXTS = {&#10;        &quot;Programming is the art of telling another human what one wants the computer to do. It requires precision, logic, and creativity in equal measure.&quot;,&#10;        &quot;The difference between theory and practice is that in theory there is no difference, but in practice there is. This paradox applies to many areas of life.&quot;,&#10;        &quot;Innovation distinguishes between a leader and a follower. Those who dare to think differently often change the world in profound ways.&quot;&#10;    };&#10;&#10;    @FXML&#10;    public void initialize() {&#10;        // Get data from GameData singleton&#10;        GameData gameData = GameData.getInstance();&#10;        String playerName = gameData.getPlayerName() != null ? gameData.getPlayerName() : &quot;Player&quot;;&#10;        String difficulty = gameData.getDifficulty() != null ? gameData.getDifficulty() : &quot;Easy&quot;;&#10;        String mode = gameData.getMode();&#10;        String timeLimit = gameData.getTime();&#10;&#10;        // Determine game mode&#10;        endlessMode = mode != null &amp;&amp; mode.equalsIgnoreCase(&quot;Endless Mode&quot;);&#10;        timeChallengeMode = mode != null &amp;&amp; mode.equalsIgnoreCase(&quot;Time Challenge&quot;);&#10;&#10;        // Parse time limit for Time Challenge mode&#10;        if (timeChallengeMode &amp;&amp; timeLimit != null) {&#10;            timeLimitSeconds = parseTimeLimit(timeLimit);&#10;        }&#10;&#10;        // Configure timer/infinity visuals based on mode&#10;        if (endlessMode) {&#10;            // Show infinity image, hide time text&#10;            if (infinityImage != null) infinityImage.setVisible(true);&#10;            if (timeText != null) timeText.setVisible(false);&#10;        } else {&#10;            // Time challenge or other mode: hide infinity image, show timer&#10;            if (infinityImage != null) infinityImage.setVisible(false);&#10;            if (timeText != null) {&#10;                timeText.setVisible(true);&#10;                // Set initial countdown time for Time Challenge mode&#10;                if (timeChallengeMode &amp;&amp; timeLimitSeconds &gt; 0) {&#10;                    int minutes = timeLimitSeconds / 60;&#10;                    int seconds = timeLimitSeconds % 60;&#10;                    timeText.setText(String.format(&quot;%d:%02d&quot;, minutes, seconds));&#10;                }&#10;            }&#10;        }&#10;&#10;        // Truncate player name to 30 characters maximum with ellipsis&#10;        if (playerName.length() &gt; 30) {&#10;            playerName = playerName.substring(0, 30) + &quot;...&quot;;&#10;        }&#10;&#10;        // Set the text values&#10;        playerNameText.setText(playerName);&#10;        difficultyText.setText(difficulty + &quot; Level&quot;);&#10;&#10;        // Select text based on difficulty&#10;        targetText = selectTextByDifficulty(difficulty);&#10;&#10;        // Display the target text&#10;        updateTextDisplay(&quot;&quot;);&#10;&#10;        // Add listener to typing field&#10;        typingField.textProperty().addListener((observable, oldValue, newValue) -&gt; {&#10;            if (!gameStarted &amp;&amp; !newValue.isEmpty()) {&#10;                startGame();&#10;            }&#10;            if (!gameFinished) {&#10;                updateTextDisplay(newValue);&#10;                checkCompletion(newValue);&#10;            }&#10;        });&#10;&#10;        // Focus on typing field&#10;        typingField.requestFocus();&#10;    }&#10;&#10;    private String selectTextByDifficulty(String difficulty) {&#10;        String[] texts;&#10;        switch (difficulty.toLowerCase()) {&#10;            case &quot;easy&quot;:&#10;                texts = EASY_TEXTS;&#10;                break;&#10;            case &quot;medium&quot;:&#10;                texts = MEDIUM_TEXTS;&#10;                break;&#10;            case &quot;hard&quot;:&#10;                texts = HARD_TEXTS;&#10;                break;&#10;            default:&#10;                texts = EASY_TEXTS;&#10;        }&#10;        // Select a random text from the array&#10;        return texts[(int) (Math.random() * texts.length)];&#10;    }&#10;&#10;    private int parseTimeLimit(String timeLimit) {&#10;        // Parse time limits like &quot;1 Minute&quot;, &quot;3 Minutes&quot;, &quot;5 Minutes&quot;&#10;        if (timeLimit == null) return 0;&#10;&#10;        String[] parts = timeLimit.split(&quot; &quot;);&#10;        if (parts.length &gt; 0) {&#10;            try {&#10;                int minutes = Integer.parseInt(parts[0]);&#10;                return minutes * 60; // Convert to seconds&#10;            } catch (NumberFormatException e) {&#10;                System.err.println(&quot;Could not parse time limit: &quot; + timeLimit);&#10;                return 0;&#10;            }&#10;        }&#10;        return 0;&#10;    }&#10;&#10;    private void startGame() {&#10;        gameStarted = true;&#10;        if (endlessMode) {&#10;            // Endless mode: no timer needed&#10;            return;&#10;        }&#10;&#10;        startTime = System.nanoTime();&#10;        countdownStartTime = System.nanoTime();&#10;&#10;        if (timeChallengeMode &amp;&amp; timeLimitSeconds &gt; 0) {&#10;            // Time Challenge mode: countdown timer&#10;            timer = new AnimationTimer() {&#10;                @Override&#10;                public void handle(long now) {&#10;                    long elapsedMillis = (now - countdownStartTime) / 1_000_000;&#10;                    int elapsedSeconds = (int) (elapsedMillis / 1000);&#10;                    int remainingSeconds = timeLimitSeconds - elapsedSeconds;&#10;&#10;                    if (remainingSeconds &lt;= 0) {&#10;                        // Time's up!&#10;                        remainingSeconds = 0;&#10;                        if (timeText != null) {&#10;                            timeText.setText(&quot;0:00&quot;);&#10;                        }&#10;                        handleTimeUp();&#10;                        return;&#10;                    }&#10;&#10;                    int minutes = remainingSeconds / 60;&#10;                    int seconds = remainingSeconds % 60;&#10;                    if (timeText != null) {&#10;                        timeText.setText(String.format(&quot;%d:%02d&quot;, minutes, seconds));&#10;                    }&#10;                }&#10;            };&#10;        } else {&#10;            // Regular count-up timer for other modes&#10;            timer = new AnimationTimer() {&#10;                @Override&#10;                public void handle(long now) {&#10;                    long elapsedMillis = (now - startTime) / 1_000_000;&#10;                    int seconds = (int) (elapsedMillis / 1000);&#10;                    int minutes = seconds / 60;&#10;                    seconds = seconds % 60;&#10;                    if (timeText != null) {&#10;                        timeText.setText(String.format(&quot;%d:%02d&quot;, minutes, seconds));&#10;                    }&#10;                }&#10;            };&#10;        }&#10;        timer.start();&#10;    }&#10;&#10;    private void handleTimeUp() {&#10;        if (!gameFinished) {&#10;            gameFinished = true;&#10;            if (timer != null) {&#10;                timer.stop();&#10;            }&#10;            typingField.setDisable(true);&#10;            System.out.println(&quot;Time's up! Game over.&quot;);&#10;            // Navigate to loading screen&#10;            try {&#10;                loadLoadingScreen();&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;                System.err.println(&quot;Error loading loading-screen.fxml: &quot; + e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    private void updateTextDisplay(String typedText) {&#10;        dataTextFlow.getChildren().clear();&#10;&#10;        for (int i = 0; i &lt; targetText.length(); i++) {&#10;            Text charText = new Text(String.valueOf(targetText.charAt(i)));&#10;            charText.setFont(Font.font(&quot;Arial&quot;, 28));&#10;&#10;            if (i &lt; typedText.length()) {&#10;                // Character has been typed&#10;                if (typedText.charAt(i) == targetText.charAt(i)) {&#10;                    // Correct character - green&#10;                    charText.setFill(Color.web(&quot;#28a745&quot;));&#10;                } else {&#10;                    // Incorrect character - red&#10;                    charText.setFill(Color.web(&quot;#dc3545&quot;));&#10;                }&#10;            } else {&#10;                // Character not yet typed - black&#10;                charText.setFill(Color.BLACK);&#10;            }&#10;&#10;            dataTextFlow.getChildren().add(charText);&#10;        }&#10;    }&#10;&#10;    private void checkCompletion(String typedText) {&#10;        if (typedText.equals(targetText)) {&#10;            gameFinished = true;&#10;            if (timer != null) {&#10;                timer.stop();&#10;            }&#10;            typingField.setDisable(true);&#10;&#10;            if (!endlessMode) {&#10;                // Calculate final time only for timed modes&#10;                long elapsedMillis = (System.nanoTime() - startTime) / 1_000_000;&#10;                int seconds = (int) (elapsedMillis / 1000);&#10;                int minutes = seconds / 60;&#10;                seconds = seconds % 60;&#10;                System.out.println(&quot;Game completed in &quot; + minutes + &quot;:&quot; + String.format(&quot;%02d&quot;, seconds));&#10;            } else {&#10;                System.out.println(&quot;Endless mode text completed.&quot;);&#10;            }&#10;            // Navigate to loading screen&#10;            try {&#10;                loadLoadingScreen();&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;                System.err.println(&quot;Error loading loading-screen.fxml: &quot; + e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    public void onBack(ActionEvent event) {&#10;        System.out.println(&quot;Back button clicked!&quot;);&#10;        if (timer != null) {&#10;            timer.stop();&#10;        }&#10;        try {&#10;            switchTo(event, &quot;ready-scene.fxml&quot;);&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;            System.err.println(&quot;Error loading ready-scene.fxml: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void switchTo(ActionEvent event, String fxmlName) throws IOException {&#10;        FXMLLoader loader = new FXMLLoader(getClass().getResource(fxmlName));&#10;        Parent root = loader.load();&#10;        Stage stage = (Stage) ((Node) event.getSource()).getScene().getWindow();&#10;        Scene scene = new Scene(root, 760, 495);&#10;        stage.setScene(scene);&#10;        stage.show();&#10;    }&#10;&#10;    private void loadLoadingScreen() throws IOException {&#10;        FXMLLoader loader = new FXMLLoader(getClass().getResource(&quot;loading-screen.fxml&quot;));&#10;        Parent root = loader.load();&#10;        Stage stage = (Stage) typingField.getScene().getWindow();&#10;        Scene scene = new Scene(root, 760, 495);&#10;        stage.setScene(scene);&#10;        stage.show();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/com/example/typejam/loading-screen.fxml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/com/example/typejam/loading-screen.fxml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&#10;&lt;?import javafx.scene.layout.StackPane?&gt;&#10;&lt;?import javafx.scene.layout.VBox?&gt;&#10;&lt;?import javafx.scene.control.ProgressIndicator?&gt;&#10;&lt;?import javafx.scene.text.Text?&gt;&#10;&lt;?import javafx.scene.text.Font?&gt;&#10;&#10;&lt;StackPane prefHeight=&quot;495.0&quot; prefWidth=&quot;760.0&quot; style=&quot;-fx-background-color: #2B5237;&quot; xmlns=&quot;http://javafx.com/javafx/24.0.1&quot; xmlns:fx=&quot;http://javafx.com/fxml/1&quot; fx:controller=&quot;com.example.typejam.LoadingScreenController&quot;&gt;&#10;   &lt;children&gt;&#10;      &lt;VBox alignment=&quot;CENTER&quot; spacing=&quot;30.0&quot;&gt;&#10;         &lt;children&gt;&#10;            &lt;ProgressIndicator fx:id=&quot;loadingSpinner&quot; prefHeight=&quot;100.0&quot; prefWidth=&quot;100.0&quot; style=&quot;-fx-progress-color: white;&quot; /&gt;&#10;            &lt;Text fill=&quot;WHITE&quot; strokeType=&quot;OUTSIDE&quot; strokeWidth=&quot;0.0&quot; text=&quot;Loading Result....&quot;&gt;&#10;               &lt;font&gt;&#10;                  &lt;Font name=&quot;Arial Bold&quot; size=&quot;32.0&quot; /&gt;&#10;               &lt;/font&gt;&#10;            &lt;/Text&gt;&#10;         &lt;/children&gt;&#10;      &lt;/VBox&gt;&#10;   &lt;/children&gt;&#10;&lt;/StackPane&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/com/example/typejam/result-scene.fxml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/com/example/typejam/result-scene.fxml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&#10;&lt;?import javafx.geometry.Insets?&gt;&#10;&lt;?import javafx.scene.control.Button?&gt;&#10;&lt;?import javafx.scene.image.Image?&gt;&#10;&lt;?import javafx.scene.image.ImageView?&gt;&#10;&lt;?import javafx.scene.layout.AnchorPane?&gt;&#10;&lt;?import javafx.scene.layout.HBox?&gt;&#10;&lt;?import javafx.scene.layout.StackPane?&gt;&#10;&lt;?import javafx.scene.layout.VBox?&gt;&#10;&lt;?import javafx.scene.shape.Rectangle?&gt;&#10;&lt;?import javafx.scene.text.Font?&gt;&#10;&lt;?import javafx.scene.text.Text?&gt;&#10;&#10;&lt;AnchorPane prefHeight=&quot;495.0&quot; prefWidth=&quot;760.0&quot; xmlns=&quot;http://javafx.com/javafx/24.0.1&quot; xmlns:fx=&quot;http://javafx.com/fxml/1&quot; fx:controller=&quot;com.example.typejam.ResultSceneController&quot;&gt;&#10;   &lt;children&gt;&#10;      &lt;StackPane prefHeight=&quot;496.0&quot; prefWidth=&quot;761.0&quot;&gt;&#10;         &lt;children&gt;&#10;            &lt;Rectangle arcHeight=&quot;5.0&quot; arcWidth=&quot;5.0&quot; fill=&quot;#2b5237&quot; height=&quot;506.0&quot; stroke=&quot;BLACK&quot; strokeType=&quot;INSIDE&quot; strokeWidth=&quot;0.0&quot; width=&quot;768.0&quot; /&gt;&#10;            &lt;Rectangle arcHeight=&quot;5.0&quot; arcWidth=&quot;5.0&quot; fill=&quot;WHITE&quot; height=&quot;400.0&quot; stroke=&quot;BLACK&quot; strokeType=&quot;INSIDE&quot; strokeWidth=&quot;0.0&quot; style=&quot;-fx-arc-height: 50; -fx-arc-width: 50;&quot; width=&quot;670.0&quot; /&gt;&#10;         &lt;/children&gt;&#10;      &lt;/StackPane&gt;&#10;      &lt;VBox alignment=&quot;TOP_CENTER&quot; layoutX=&quot;45.0&quot; layoutY=&quot;48.0&quot; prefHeight=&quot;400.0&quot; prefWidth=&quot;670.0&quot; spacing=&quot;20.0&quot;&gt;&#10;         &lt;children&gt;&#10;            &lt;Text fill=&quot;#2b5237&quot; strokeType=&quot;OUTSIDE&quot; strokeWidth=&quot;0.0&quot; text=&quot;Result&quot; textAlignment=&quot;CENTER&quot;&gt;&#10;               &lt;font&gt;&#10;                  &lt;Font name=&quot;Arial Bold&quot; size=&quot;48.0&quot; /&gt;&#10;               &lt;/font&gt;&#10;               &lt;VBox.margin&gt;&#10;                  &lt;Insets top=&quot;30.0&quot; /&gt;&#10;               &lt;/VBox.margin&gt;&#10;            &lt;/Text&gt;&#10;            &lt;Text strokeType=&quot;OUTSIDE&quot; strokeWidth=&quot;0.0&quot; text=&quot;Game Completed!&quot; textAlignment=&quot;CENTER&quot;&gt;&#10;               &lt;font&gt;&#10;                  &lt;Font name=&quot;Arial&quot; size=&quot;24.0&quot; /&gt;&#10;               &lt;/font&gt;&#10;            &lt;/Text&gt;&#10;         &lt;/children&gt;&#10;      &lt;/VBox&gt;&#10;      &lt;HBox alignment=&quot;CENTER&quot; layoutX=&quot;44.0&quot; layoutY=&quot;50.0&quot; prefHeight=&quot;70.0&quot; prefWidth=&quot;94.0&quot;&gt;&#10;         &lt;children&gt;&#10;            &lt;Button fx:id=&quot;backButton&quot; mnemonicParsing=&quot;false&quot; onAction=&quot;#onBack&quot; prefHeight=&quot;52.0&quot; style=&quot;-fx-background-color: white; -fx-background-radius: 100;&quot;&gt;&#10;               &lt;graphic&gt;&#10;                  &lt;ImageView fitHeight=&quot;52.0&quot; fitWidth=&quot;52.0&quot; pickOnBounds=&quot;true&quot; preserveRatio=&quot;false&quot;&gt;&#10;                     &lt;image&gt;&#10;                        &lt;Image url=&quot;@../../../assets/back.png&quot; /&gt;&#10;                     &lt;/image&gt;&#10;                  &lt;/ImageView&gt;&#10;               &lt;/graphic&gt;&#10;            &lt;/Button&gt;&#10;         &lt;/children&gt;&#10;      &lt;/HBox&gt;&#10;   &lt;/children&gt;&#10;&lt;/AnchorPane&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>